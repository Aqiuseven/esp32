# 定时中断

## 1 . 提要

在前述中，我们提到了可以用延时来控制LED灯按秒关/亮。这样的开发似乎简单优雅也没有任何问题。<font color=Crimson>但是</font>，在C开发的单片机中，一些延时需要通过无用循环的空转来实现，例如这样：

```c
#include<reg52.h>

void delay(int time){  // [!code highlight:5]
    for(int i=0;i<=time;i++){
        for(int item=0;item<=500;item++)
    }
} // 做无用循环，让单片机空转，以实现延时功能

int main(){
    printf("h");
    delay(100); // [!code highlight]
    printf("i");
}
```

在上面的代码里，我们就可以看到，单片机在延时时，会做没有意义的空转，这时候这个<span style="border-bottom:2px dashed yellow;">进程始终占用cpu，其他进程就不能利用cpu完成任务</span>。

但是多进程的本质就是利用不同进程的空闲时间，交换CPU控制权以此来实现多进程的功能（此部分后面会详细提及），那在这种情况下，我应该<span style="border-bottom:2px dashed yellow;">怎么优化这个延时？</span>



## 2 . 定时器定时中断

同名字一样，定时器会定时，定时到了，会中断(打断)一下程序的运行。完整的理解就是：<font color=DarkCyan>定时结束时，单片机会暂停当前进程，优先完成定时中断中需要完成的事情</font>，以下是示例参考：
```python
import machine

def callback(timer):
    print("定时器周期性触发")

'''
提供 4 个定时器 id 为 0-3
'''
timer = machine.Timer(0) # 创建ID 0 的计时器  // [!code highlight]

'''
init的3个参数
period ： 定时时长，单位ms
mode ： 中断类型
    - machine.Timer.ONE_SHOT ：中断只触发一次
    - machine.Timer.PERIODIC ：重复触发
callback ： 定时回调函数，就是定时时间到了会触发的函数
'''
timer.init(period=1000, mode=machine.Timer.PERIODIC, callback=callback) #  [!code highlight]
```



## 💡 3 . 拓展学习

上述已经介绍了，如何使用定时中断，可以通过修改定时回调函数来实现LED的一秒亮灭一次

### 任务要求

> 改造第一个例程，使用定时中断的方式实现LED一秒开关一次。



### 效果演示

略



### 参考例程

